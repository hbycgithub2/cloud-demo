# RocketMQ Demo 快速测试指南

## 一、环境准备（5分钟）

### 1. 启动RocketMQ
```bash
# 第1步：启动NameServer（新开CMD窗口）
cd D:\rocketmq\bin
start mqnamesrv.cmd

# 第2步：启动Broker（新开CMD窗口）
cd D:\rocketmq\bin
start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true

# 验证启动成功
jps -l
# 应该看到：
# NamesrvStartup
# BrokerStartup
```

### 2. 初始化数据库
```bash
# 进入MySQL
mysql -uroot -p

# 执行初始化脚本
source D:/code/cloud-demo/cloud-demo/rocketmq-demo/init.sql

# 验证数据
USE cloud_rocketmq;
SHOW TABLES;
SELECT COUNT(*) FROM tb_order;      -- 应该返回10
SELECT COUNT(*) FROM tb_stock;      -- 应该返回3
```

## 二、启动服务（2分钟）

### 方式1：IDEA启动（推荐）
```
1. 打开IDEA，导入cloud-demo项目
2. 找到ProducerApplication，右键Run（8090端口）
3. 找到ConsumerApplication，右键Run（8091端口）
```

### 方式2：Maven启动
```bash
# 启动生产者（新开CMD窗口）
cd D:\code\cloud-demo\cloud-demo\rocketmq-demo\rocketmq-producer
mvn spring-boot:run

# 启动消费者（新开CMD窗口）
cd D:\code\cloud-demo\cloud-demo\rocketmq-demo\rocketmq-consumer
mvn spring-boot:run
```

### 验证启动成功
```
生产者控制台应该显示：
========================================
RocketMQ生产者启动成功！端口：8090
========================================

消费者控制台应该显示：
========================================
RocketMQ消费者启动成功！端口：8091
========================================
```

## 三、快速测试（10分钟）

### 测试1：普通消息（最简单）⭐
```bash
# 使用curl测试
curl -X POST http://localhost:8090/message/send ^
-H "Content-Type: application/json" ^
-d "{\"userId\":1001,\"productName\":\"iPhone 15 Pro\",\"price\":7999.00,\"quantity\":1}"

# 预期结果：
# 1. 生产者返回：{"success":true,"message":"普通消息发送成功","orderNo":"ORD..."}
# 2. 消费者控制台打印：收到订单消息，短信发送成功
# 3. 数据库验证：
SELECT * FROM tb_order ORDER BY id DESC LIMIT 1;
SELECT * FROM tb_sms_log ORDER BY id DESC LIMIT 1;
```

### 测试2：延迟消息（需要等待）
```bash
curl -X POST http://localhost:8090/message/sendDelay ^
-H "Content-Type: application/json" ^
-d "{\"userId\":1002,\"productName\":\"MacBook Pro\",\"price\":12999.00,\"quantity\":1}"

# 预期结果：
# 1. 立即返回：订单创建成功（status=0待支付）
# 2. 30分钟后：消费者自动取消订单（status=-1）

# 快速测试（不等30分钟）：
# 修改MessageService.java第60行，将延迟级别改为3（10秒）
# SendResult result = rocketMQTemplate.syncSend("cancel-topic", message, 3000, 3);
# 重启生产者，再次测试，10秒后订单自动取消
```

### 测试3：事务消息（最重要）⭐⭐⭐
```bash
curl -X POST http://localhost:8090/message/sendTransaction ^
-H "Content-Type: application/json" ^
-d "{\"userId\":1003,\"productName\":\"iPhone 15 Pro\",\"price\":7999.00,\"quantity\":2}"

# 预期结果：
# 1. 生产者：执行本地事务，保存订单成功
# 2. 消费者：收到消息，扣减库存成功
# 3. 数据库验证：
SELECT * FROM tb_order WHERE order_no = 'ORD...';
SELECT * FROM tb_stock WHERE product_name = 'iPhone 15 Pro';
SELECT * FROM tb_stock_log WHERE order_no = 'ORD...';
```

### 测试4：顺序消息
```bash
# 第1步：创建订单
curl -X POST http://localhost:8090/message/send ^
-H "Content-Type: application/json" ^
-d "{\"userId\":1004,\"productName\":\"AirPods Pro\",\"price\":1999.00,\"quantity\":1}"

# 记录返回的订单号：ORD20260207...

# 第2步：按顺序发送状态变更消息
curl -X POST http://localhost:8090/message/sendOrderly ^
-H "Content-Type: application/json" ^
-d "{\"orderNo\":\"ORD20260207...\",\"status\":1}"

curl -X POST http://localhost:8090/message/sendOrderly ^
-H "Content-Type: application/json" ^
-d "{\"orderNo\":\"ORD20260207...\",\"status\":2}"

curl -X POST http://localhost:8090/message/sendOrderly ^
-H "Content-Type: application/json" ^
-d "{\"orderNo\":\"ORD20260207...\",\"status\":3}"

# 预期结果：
# 消费者按顺序消费，订单状态依次变更：0→1→2→3
SELECT * FROM tb_order WHERE order_no = 'ORD20260207...';
```

### 测试5：批量消息
```bash
curl -X POST http://localhost:8090/message/sendBatch ^
-H "Content-Type: application/json" ^
-d "{\"userIds\":[1001,1002,1003,1004,1005,1006,1007,1008,1009,1010]}"

# 预期结果：
# 1. 生产者：批量发送10条消息成功
# 2. 消费者：收到10条消息，发放10张优惠券
# 3. 数据库验证：
SELECT COUNT(*) FROM tb_coupon WHERE user_id IN (1001,1002,1003,1004,1005,1006,1007,1008,1009,1010);
-- 应该返回10（加上测试数据中已有的）
```

### 测试6：消息过滤（VIP）⭐
```bash
# 发送VIP订单
curl -X POST http://localhost:8090/message/sendVip ^
-H "Content-Type: application/json" ^
-d "{\"userId\":1006,\"productName\":\"AirPods Pro\",\"price\":1999.00,\"quantity\":1}"

# 预期结果：
# 1. 生产者：VIP订单创建成功（is_vip=1）
# 2. 消费者：VipSmsConsumer收到消息，发送VIP专属短信
# 3. 数据库验证：
SELECT * FROM tb_order WHERE is_vip = 1 ORDER BY id DESC LIMIT 1;
SELECT * FROM tb_sms_log WHERE content LIKE '%VIP%' ORDER BY id DESC LIMIT 1;
```

## 四、使用Postman测试（推荐）

### 1. 导入测试集合
```
1. 打开Postman
2. 点击Import
3. 选择文件：D:\code\cloud-demo\cloud-demo\rocketmq-demo\RocketMQ-Test.postman_collection.json
4. 导入成功后，左侧会显示"RocketMQ Demo"文件夹
```

### 2. 测试顺序
```
1. 场景1：普通消息 - 发送短信通知
2. 场景3：事务消息 - 订单和库存一致性
3. 场景6：消息过滤 - 只处理VIP订单
4. 场景5：批量消息 - 批量发送优惠券
5. 场景4：顺序消息 - 订单状态变更
6. 场景2：延迟消息 - 自动取消超时订单（最后测试）
```

## 五、验证结果

### 1. 查看控制台日志
```
生产者控制台：
- 订单创建成功：订单号=ORD...
- 普通消息发送成功：订单号=ORD...
- 事务消息发送成功：订单号=ORD...

消费者控制台：
- ========== 普通消息消费 ==========
- 收到订单消息：订单号=ORD..., 商品=iPhone 15 Pro
- 短信发送成功：手机号=138****1001
- ==================================
```

### 2. 查看数据库
```sql
-- 订单数量
SELECT COUNT(*) FROM tb_order;

-- 短信记录
SELECT COUNT(*) FROM tb_sms_log;

-- 库存情况
SELECT product_name, stock, version FROM tb_stock;

-- 库存扣减记录
SELECT COUNT(*) FROM tb_stock_log;

-- 优惠券数量
SELECT COUNT(*) FROM tb_coupon;

-- VIP订单
SELECT * FROM tb_order WHERE is_vip = 1;
```

### 3. 查看P6Spy SQL日志
```
控制台会打印完整SQL（包含参数值）：
[2ms] INSERT INTO tb_order (order_no, user_id, product_name, price, quantity, status, is_vip, create_time) VALUES ('ORD20260207...', 1001, 'iPhone 15 Pro', 7999.00, 1, 0, 0, NOW())
```

## 六、常见问题排查

### 问题1：RocketMQ连接失败
```
错误：connect to <127.0.0.1:9876> failed

解决：
1. 检查RocketMQ是否启动：jps -l
2. 检查端口是否被占用：netstat -ano | findstr 9876
3. 重启RocketMQ
```

### 问题2：消费者收不到消息
```
原因：Topic不存在

解决：
1. 启动Broker时添加参数：autoCreateTopicEnable=true
2. 或手动创建Topic：
   mqadmin updateTopic -n 127.0.0.1:9876 -t order-topic -c DefaultCluster
```

### 问题3：数据库连接失败
```
错误：Access denied for user 'root'@'localhost'

解决：
1. 检查MySQL是否启动
2. 检查用户名密码是否正确（application.yml）
3. 检查数据库是否存在：SHOW DATABASES LIKE 'cloud_rocketmq';
```

### 问题4：端口被占用
```
错误：Port 8090 was already in use

解决：
1. 查看占用端口的进程：netstat -ano | findstr 8090
2. 杀死进程：taskkill /F /PID <进程ID>
3. 或修改端口：application.yml中修改server.port
```

## 七、性能测试（可选）

### 使用JMeter压测
```bash
# 1. 下载JMeter
# 2. 创建测试计划
# 3. 添加HTTP请求
# 4. 设置并发数：1000
# 5. 设置持续时间：1分钟
# 6. 运行测试

# 预期性能：
# - 生产者QPS：10000+
# - 消费者QPS：10000+
# - 消息延迟：<10ms
```

## 八、测试完成清单

- [ ] RocketMQ启动成功
- [ ] 数据库初始化成功
- [ ] 生产者启动成功（8090）
- [ ] 消费者启动成功（8091）
- [ ] 场景1：普通消息测试通过
- [ ] 场景2：延迟消息测试通过
- [ ] 场景3：事务消息测试通过
- [ ] 场景4：顺序消息测试通过
- [ ] 场景5：批量消息测试通过
- [ ] 场景6：消息过滤测试通过
- [ ] 数据库数据验证通过
- [ ] P6Spy日志正常输出

## 九、下一步

测试通过后，可以：
1. 修改代码，添加自己的业务逻辑
2. 调整RocketMQ配置，优化性能
3. 集成到自己的项目中
4. 学习RocketMQ高级特性（死信队列、消息追踪等）

---

**测试时间：约20分钟**  
**难度：⭐⭐（简单）**  
**推荐测试顺序：场景1 → 场景3 → 场景6 → 场景5 → 场景4 → 场景2**
