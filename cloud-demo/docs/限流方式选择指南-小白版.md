# 限流方式选择指南 - 小白版

## 一、3 秒钟快速决策

### 问题 1：你的项目有多少用户？

```
A. 几百人（小项目）
   → 用【计数器限流】
   → 最简单，够用了

B. 几千到几万人（中型项目）
   → 用【令牌桶限流】
   → 性能好，推荐

C. 几十万到几百万人（大型项目）
   → 用【多层限流】
   → 淘宝、京东都这么用
```

---

### 问题 2：你最担心什么问题？

```
A. 担心服务器崩溃
   → 用【全局限流】
   → 保护整个系统

B. 担心某个接口被刷爆
   → 用【接口限流】
   → 保护单个接口

C. 担心有人恶意刷接口
   → 用【用户限流】
   → 每个用户限制次数

D. 担心被攻击
   → 用【IP 限流】
   → 每个 IP 限制次数
```

---

### 问题 3：你的项目类型是什么？

```
A. 电商（秒杀、抢购）
   → 用【令牌桶 + 队列】
   → 京东就这么用

B. 社交（直播、弹幕）
   → 用【用户限流】
   → 抖音就这么用

C. 内容（新闻、视频）
   → 用【接口限流】
   → 保护查询接口

D. 普通网站
   → 用【全局限流】
   → 简单够用
```

---

## 二、5 种常见场景 + 解决方案

### 场景 1：小项目（几百人）

**问题：**
- 用户不多，但担心服务器崩溃

**解决方案：计数器限流（最简单）**

```java
// 1. 添加依赖（Spring Boot）
// pom.xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>31.1-jre</version>
</dependency>

// 2. 写一个过滤器
@Component
public class SimpleRateLimitFilter implements GlobalFilter {
    
    // 限流：每秒最多 100 个请求
    private static final int MAX_REQUESTS = 100;
    private AtomicInteger counter = new AtomicInteger(0);
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 计数器 +1
        int count = counter.incrementAndGet();
        
        // 超过限制，拒绝
        if (count > MAX_REQUESTS) {
            exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
            return exchange.getResponse().setComplete();
        }
        
        // 没超过，放行
        return chain.filter(exchange);
    }
    
    // 每秒重置计数器
    @Scheduled(fixedRate = 1000)
    public void reset() {
        counter.set(0);
    }
}
```

**优点：**
- ✅ 超级简单，10 行代码搞定
- ✅ 够用了

**缺点：**
- ⚠️ 用户多了不够用

---

### 场景 2：中型项目（几千到几万人）

**问题：**
- 用户比较多，需要更精确的限流

**解决方案：令牌桶限流（推荐）**

```java
// 1. 添加依赖
// pom.xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>31.1-jre</version>
</dependency>

// 2. 写一个过滤器
@Component
public class TokenBucketRateLimitFilter implements GlobalFilter {
    
    // 令牌桶：每秒生成 100 个令牌
    private final RateLimiter rateLimiter = RateLimiter.create(100);
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 尝试获取 1 个令牌（等待 0 秒）
        if (!rateLimiter.tryAcquire(1, 0, TimeUnit.SECONDS)) {
            // 没有令牌，拒绝
            exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
            return exchange.getResponse().setComplete();
        }
        
        // 有令牌，放行
        return chain.filter(exchange);
    }
}
```

**优点：**
- ✅ 简单（只需要 1 行代码：`RateLimiter.create(100)`）
- ✅ 性能好
- ✅ 可以应对突发流量

**推荐：大部分项目用这个就够了！**

---

### 场景 3：电商秒杀（抢购）

**问题：**
- 1000 台手机，100 万人抢购
- 只有 1000 人能抢到

**解决方案：令牌桶 + 队列**

```java
// 1. 令牌桶限流（只让 1000 人通过）
@Component
public class SeckillRateLimitFilter implements GlobalFilter {
    
    // 令牌桶：总共 1000 个令牌
    private final Semaphore semaphore = new Semaphore(1000);
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 尝试获取 1 个令牌
        if (!semaphore.tryAcquire()) {
            // 没有令牌，拒绝
            exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
            return exchange.getResponse().setComplete();
        }
        
        // 有令牌，放行
        return chain.filter(exchange).doFinally(signalType -> {
            // 请求结束后，释放令牌
            semaphore.release();
        });
    }
}

// 2. 消息队列（按顺序处理）
@Service
public class SeckillService {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    // 秒杀接口
    public Result seckill(Long userId, Long productId) {
        // 发送到消息队列
        SeckillMessage message = new SeckillMessage(userId, productId);
        rabbitTemplate.convertAndSend("seckill.queue", message);
        
        return Result.success("排队中，请稍后查看结果");
    }
    
    // 消费消息（按顺序处理）
    @RabbitListener(queues = "seckill.queue")
    public void processSeckill(SeckillMessage message) {
        // 1. 检查库存
        if (productService.getStock(message.getProductId()) <= 0) {
            return;  // 库存不足
        }
        
        // 2. 扣减库存
        productService.decreaseStock(message.getProductId());
        
        // 3. 创建订单
        orderService.create(message.getUserId(), message.getProductId());
    }
}
```

**优点：**
- ✅ 不会超卖
- ✅ 按顺序处理
- ✅ 服务器不会崩溃

---

### 场景 4：防止恶意刷接口

**问题：**
- 有人用脚本刷接口
- 每秒刷 1000 次

**解决方案：用户限流**

```java
@Component
public class UserRateLimitFilter implements GlobalFilter {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 1. 获取用户 ID（从 Token 解析）
        String userId = getUserIdFromToken(exchange);
        
        // 2. Redis key
        String currentSecond = String.valueOf(System.currentTimeMillis() / 1000);
        String key = "rate_limit:user:" + userId + ":" + currentSecond;
        
        // 3. 计数器 +1
        Long count = redisTemplate.opsForValue().increment(key);
        
        // 4. 设置过期时间
        if (count == 1) {
            redisTemplate.expire(key, 2, TimeUnit.SECONDS);
        }
        
        // 5. 检查是否超过限制（每个用户每秒最多 10 次）
        if (count > 10) {
            exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
            return exchange.getResponse().setComplete();
        }
        
        return chain.filter(exchange);
    }
}
```

**优点：**
- ✅ 防止单个用户恶意刷接口
- ✅ 不影响其他用户

---

### 场景 5：大型项目（几十万到几百万人）

**问题：**
- 用户很多，流量很大
- 需要多层保护

**解决方案：多层限流**

```java
// 第 1 层：全局限流（保护整个系统）
@Component
@Order(1)
public class GlobalRateLimitFilter implements GlobalFilter {
    private final RateLimiter rateLimiter = RateLimiter.create(100000);  // 每秒 10 万次
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        if (!rateLimiter.tryAcquire()) {
            exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
            return exchange.getResponse().setComplete();
        }
        return chain.filter(exchange);
    }
    
    @Override
    public int getOrder() {
        return 1;
    }
}

// 第 2 层：接口限流（保护单个接口）
@Component
@Order(2)
public class ApiRateLimitFilter implements GlobalFilter {
    
    private Map<String, RateLimiter> rateLimiters = new HashMap<>();
    
    public ApiRateLimitFilter() {
        // 不同接口不同限制
        rateLimiters.put("/user/**", RateLimiter.create(10000));   // 每秒 1 万次
        rateLimiters.put("/order/**", RateLimiter.create(5000));   // 每秒 5000 次
        rateLimiters.put("/product/**", RateLimiter.create(20000)); // 每秒 2 万次
    }
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String path = exchange.getRequest().getPath().value();
        
        // 找到对应的限流器
        RateLimiter rateLimiter = rateLimiters.entrySet().stream()
            .filter(entry -> path.startsWith(entry.getKey().replace("/**", "")))
            .map(Map.Entry::getValue)
            .findFirst()
            .orElse(null);
        
        if (rateLimiter != null && !rateLimiter.tryAcquire()) {
            exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
            return exchange.getResponse().setComplete();
        }
        
        return chain.filter(exchange);
    }
    
    @Override
    public int getOrder() {
        return 2;
    }
}

// 第 3 层：用户限流（防止恶意刷接口）
@Component
@Order(3)
public class UserRateLimitFilter implements GlobalFilter {
    // ... (和场景 4 一样)
    
    @Override
    public int getOrder() {
        return 3;
    }
}
```

**优点：**
- ✅ 多层保护，更安全
- ✅ 大厂都这么用

---

## 三、快速决策表

| 你的情况 | 推荐方案 | 难度 | 代码量 |
|---------|---------|------|--------|
| 小项目（几百人） | 计数器限流 | ⭐ 简单 | 10 行 |
| 中型项目（几千到几万人） | 令牌桶限流 | ⭐⭐ 简单 | 5 行 |
| 电商秒杀 | 令牌桶 + 队列 | ⭐⭐⭐ 中等 | 50 行 |
| 防止恶意刷接口 | 用户限流 | ⭐⭐ 简单 | 20 行 |
| 大型项目（几十万人） | 多层限流 | ⭐⭐⭐⭐ 复杂 | 100 行 |

---

## 四、我该用哪个？（3 步决策）

### 第 1 步：看用户量

```
用户 < 1000 人：
  → 用【计数器限流】
  → 最简单

用户 1000-10 万人：
  → 用【令牌桶限流】
  → 推荐，大部分项目用这个

用户 > 10 万人：
  → 用【多层限流】
  → 大厂方案
```

---

### 第 2 步：看项目类型

```
电商（秒杀、抢购）：
  → 用【令牌桶 + 队列】
  → 防止超卖

社交（直播、弹幕）：
  → 用【用户限流】
  → 防止刷屏

内容（新闻、视频）：
  → 用【接口限流】
  → 保护查询接口

普通网站：
  → 用【全局限流】
  → 简单够用
```

---

### 第 3 步：看担心什么

```
担心服务器崩溃：
  → 用【全局限流】

担心某个接口被刷爆：
  → 用【接口限流】

担心有人恶意刷接口：
  → 用【用户限流】

担心被攻击：
  → 用【IP 限流】
```

---

## 五、推荐方案（90% 的项目用这个）

### 方案：令牌桶限流（Guava RateLimiter）

**为什么推荐：**
- ✅ 简单（只需要 1 行代码）
- ✅ 性能好
- ✅ 可以应对突发流量
- ✅ Google 出品，靠谱

**完整代码：**

```java
// 1. 添加依赖
// pom.xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>31.1-jre</version>
</dependency>

// 2. 写一个过滤器
@Component
public class RateLimitFilter implements GlobalFilter, Ordered {
    
    // 令牌桶：每秒生成 100 个令牌
    private final RateLimiter rateLimiter = RateLimiter.create(100);
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 尝试获取 1 个令牌
        if (!rateLimiter.tryAcquire()) {
            // 没有令牌，拒绝
            exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
            return exchange.getResponse().setComplete();
        }
        
        // 有令牌，放行
        return chain.filter(exchange);
    }
    
    @Override
    public int getOrder() {
        return -1;  // 优先级最高
    }
}

// 3. 配置限流规则（可选）
@Configuration
public class RateLimitConfig {
    
    @Bean
    public RateLimiter rateLimiter() {
        // 根据服务器性能调整
        // 1 核 2G：100/秒
        // 2 核 4G：500/秒
        // 4 核 8G：2000/秒
        return RateLimiter.create(100);
    }
}
```

**就这么简单！**

---

## 六、常见问题

### Q1：限流规则怎么设置？

**A：根据服务器性能**

```
服务器配置 → 推荐限流
1 核 2G → 100/秒
2 核 4G → 500/秒
4 核 8G → 2000/秒
8 核 16G → 5000/秒

不知道设多少？
  → 先设 100/秒
  → 压测看看服务器能不能扛住
  → 能扛住就加大，扛不住就减小
```

---

### Q2：限流后用户体验不好怎么办？

**A：返回友好的提示**

```java
if (!rateLimiter.tryAcquire()) {
    // 不要只返回 429
    // 返回友好的提示
    ServerHttpResponse response = exchange.getResponse();
    response.setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
    response.getHeaders().setContentType(MediaType.APPLICATION_JSON);
    
    String message = "{\"code\":429,\"message\":\"请求太频繁，请稍后再试\"}";
    DataBuffer buffer = response.bufferFactory().wrap(message.getBytes());
    
    return response.writeWith(Mono.just(buffer));
}
```

---

### Q3：限流会不会影响性能？

**A：几乎不影响**

```
令牌桶限流：
  - 耗时：< 0.1 毫秒
  - 影响：可以忽略不计

对比：
  - 查数据库：10 毫秒
  - 查 Redis：1 毫秒
  - 限流：0.1 毫秒

结论：不用担心性能
```

---

## 七、总结

### 小白记住这 3 点就够了

```
1. 大部分项目用【令牌桶限流】
   - 简单（1 行代码）
   - 性能好
   - 够用了

2. 电商秒杀用【令牌桶 + 队列】
   - 防止超卖
   - 按顺序处理

3. 大型项目用【多层限流】
   - 全局限流 + 接口限流 + 用户限流
   - 大厂方案
```

### 快速决策

```
用户 < 1000 人 → 计数器限流
用户 1000-10 万人 → 令牌桶限流（推荐）
用户 > 10 万人 → 多层限流

电商秒杀 → 令牌桶 + 队列
社交直播 → 用户限流
普通网站 → 全局限流
```

### 推荐代码（复制粘贴就能用）

```java
// 令牌桶限流（推荐）
@Component
public class RateLimitFilter implements GlobalFilter {
    private final RateLimiter rateLimiter = RateLimiter.create(100);  // 每秒 100 次
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        if (!rateLimiter.tryAcquire()) {
            exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
            return exchange.getResponse().setComplete();
        }
        return chain.filter(exchange);
    }
}
```

### 一句话总结

**小白记住：90% 的项目用【令牌桶限流】就够了，只需要 1 行代码（`RateLimiter.create(100)`），简单、性能好、够用。电商秒杀用【令牌桶 + 队列】，大型项目用【多层限流】。不知道设多少？先设 100/秒，压测后再调整！**
