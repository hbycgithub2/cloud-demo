

rocketMQTemplate.convertAndSend("seckill-topic", dto);

参数1："seckill-topic" - Topic（主题）
消息的分类标签，类似"频道"或"邮箱地址"
决定消息发到哪里、谁能收到消息

dto
参数2：dto - 消息体
你要发送的数据对象
决定发送什么内容

// 发送
SeckillDTO dto = new SeckillDTO(1002, 1, 1);
rocketMQTemplate.convertAndSend("seckill-topic", dto);
//                                ↑ Topic        ↑ 消息内容

// 接收
@RocketMQMessageListener(topic = "seckill-topic")
//                                ↑ 订阅这个Topic
public class SeckillConsumer implements RocketMQListener<SeckillDTO> {
    public void onMessage(SeckillDTO dto) {
        //                  ↑ 收到的消息内容
        System.out.println(dto.getUserId());  // 1002
    }
}



Topic规则
1、Producer和Consumer的Topic必须一致
// Producer发送到 seckill-topic
rocketMQTemplate.convertAndSend("seckill-topic", dto);

// Consumer订阅 seckill-topic（能收到）
@RocketMQMessageListener(topic = "seckill-topic")


2、一个Topic可以有多个Consumer
// Consumer1：处理订单
@RocketMQMessageListener(topic = "seckill-topic", consumerGroup = "order-consumer")

// Consumer2：发送短信
@RocketMQMessageListener(topic = "seckill-topic", consumerGroup = "sms-consumer")

// 两个Consumer都能收到消息

--------------------------

消息内容规则
// Producer发送 SeckillDTO
1、rocketMQTemplate.convertAndSend("seckill-topic", dto);

// Consumer接收 SeckillDTO（正确）
public class Consumer implements RocketMQListener<SeckillDTO>

// Consumer接收 String（错误，反序列化失败）
public class Consumer implements RocketMQListener<String>



更通顺的版本
版本1（最简洁）
生产者把消息发到seckill-topic，Broker找到对应的Queue存起来。

版本2（稍详细）
生产者带着dto，通过seckill-topic这个路由键，发给Broker，Broker从4个Queue里选一个存进去。

版本3（对话式，最通俗）
生产者：我要把dto发到seckill-topic
Broker：好的，seckill-topic有4个Queue，我选Queue2存
Queue2：消息已存好
版本4（流程式）
生产者指定Topic（seckill-topic）发送消息（dto）→ Broker收到后找到对应的Queue（Queue0/1/2/3）→ 轮询选一个Queue存消息。
