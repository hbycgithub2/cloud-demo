阶段一：库存预热：查秒杀商品写入Redis缓存中（key商品id  value 库存数量）
        ↓
阶段二：用户秒杀阶段
 1、立即抢购
        ↓
Lua脚本原子扣减Redis库存
Redis执行Lua脚本： 读、判、扣、返
        ↓
标记用户已秒杀(将用户id作为key value 库存数放到redis缓存)
        ↓
发送RocketMQ消息：落表只是记录数据，用户不用等（削峰、异步、解耦）：

调用rocketMQTemplate的发送方法，里传两个参数，一个是路由键，一个是消息体(里是用户id、商品id、数量)
        ↓
返回"秒杀成功"
        ↓
Consumer接收到消息后，开始异步处理秒杀订单
        ↓
  扣库存时防超卖，通过UPDATE商品表WHERE商品id和版本号（乐观锁）来控制
         ↓
    创建订单（通过商品id，拿到商品信息创建订单） 
        ↓
  记录库存日志（记录变化、排查问题、防超卖验证、审计）
        ↓ 
  记录用户秒杀记录（记录哪个用户秒杀了哪个商品）
  防重复秒杀（用户id、商品id、订单id唯一索引兜底的）



### 防超卖的3道防线
1. **Redis Lua脚本**（第6步）：原子操作，绝对不超卖
2. **MySQL乐观锁**（第8步）：version字段，防止并发更新
3. **库存日志**（第8步）：记录每次扣减，方便排查问题

### 防重复秒杀的2道防线
1. **Redis防线**（第6步）：seckill:user:{userId}:{productId}，秒杀前检查
2. **MySQL防线**（第8步）：tb_user_seckill表，唯一索引uk_user_product

为什么要用RocketMQ
Redis扣库存后，落表只是记录数据，用户不用等（削峰、异步、解耦）：

RocketMQ异步处理扣减库存表和创建订单表等落地表操作 

