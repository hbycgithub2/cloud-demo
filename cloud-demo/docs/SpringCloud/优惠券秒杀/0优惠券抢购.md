
"我在人保车险项目中负责优惠券抢购功能的开发。这是2025年1月的'开门红'活动，限量2000张优惠券，立减200元。活动吸引了5万人参与，QPS达到433次/秒，相对平时增长150倍。

我负责核心模块的设计和开发：**Redis + Lua脚本防超卖、Sentinel限流保护系统、Kafka异步写入提升响应速度**。

虽然绝对并发量不高，但我们车险业务平时QPS只有2.5次/秒，优惠券抢购时QPS达到833次/秒，**相对增长333倍**。

我们要解决的问题和电商秒杀是一样的：**防超卖、防刷、高可用**。"


**核心数字：**
- 平时QPS：2.5次/秒
- 抢券QPS：833次/秒
- 峰值QPS：1666次/秒
- 相对增长：333倍

### 必问3：Redis宕机了怎么办？

**标准答案：**
**Redis集群**（主方案）：3主3从，主节点宕机，从节点自动切换。
哨兵：多数哨兵投票决定，选数据最新的从节点当主节点。

Redis集群： 多个Redis节点，数据分片存储，提高容量和性能
哨兵： 监控Redis主从，主节点挂了自动选从节点当新主节点，保证高可用
区别： 集群解决容量问题（数据多），哨兵解决可用性问题（主节点挂了）


### 选问3：你在这个项目中的角色是什么？

**标准答案：**
"我是**核心开发**，负责**抢券接口、Redis扣减库存、Kafka异步写入**3个核心模块。




> "我们用**Redis + Lua脚本**保证原子性。
> 为什么用Lua？因为Redis单线程，Lua脚本执行期间不会被打断，**一次性完成：检查用户是否已领取 → 判断库存 → 扣减库存 → 记录用户**，整个过程原子操作，0超卖。


│ 步骤3：发送MQ消息（异步写数据库）                     │
│ rabbitTemplate.convertAndSend(                      │
│     "coupon-exchange",                              │
│     "coupon-routing-key",                           │
│     CouponMessage(couponId, userId, recordId)       │
│ ) 

返回结果："抢券成功"（25ms）



**面试官问**："Redis和Oracle数据一致性怎么保证？"

**你这样回答**：

> "我们用了**3道防线**：
> 
> **第1道：Redis扣减成功 → RabbitMQ发消息 → Oracle写入**  
> - 正常流程，99%的请求走这条路  
> 
> **第2道：RabbitMQ消费失败 → 重试3次 → 死信队列**  
> - 消费失败自动重试  
> - 3次失败进死信队列，人工处理  
> 
> **第3道：定时任务补偿（每5分钟）**  
> - 对比Redis和Oracle数据  
> - 发现不一致立即补偿（重新发送MQ消息）  
> - 告警通知运维  
> 
> 最终效果：**不一致率0%**，活动结束后对账完全一致。"

**说话技巧**：
- ✅ 说3道防线（正常流程、重试、对账）
- ✅ 说补偿机制（重新发送MQ消息）
- ✅ 说最终效果（不一致率0%）



坑2：Redis和Oracle数据不一致**  
> - 原因：RabbitMQ消费失败，消息丢了  
> - 解决：加重试机制 + 定时任务每5分钟补偿  
> 