

### 第4步：库存预热（运营人员操作）

第2步：查询MySQL商品
    SELECT * FROM tb_seckill_product WHERE id=1;
    → 查到：stock=10000
    ↓
第3步：写入Redis
    SET seckill:stock:1 10000
    ↓
第4步：返回"库存预热成功"

涉及表：tb_seckill_product（读）
涉及Redis：seckill:stock:1（写）

## 阶段二：用户秒杀阶段（秒杀进行中）

### 第5步：用户1002点击"立即抢购"
```
前端发送请求：POST /seckill/kill
{
  "userId": 1002,
  "productId": 1,
  "quantity": 1
}
```

### 第6步：seckill-service处理秒杀请求（15ms）

#### 步骤6.1：检查用户是否已秒杀
```
Redis执行：EXISTS seckill:user:1002:1
返回：0（未秒杀）

如果返回1（已秒杀）→ 直接返回"秒杀失败"（功能3：重复秒杀拦截）
```

#### 步骤6.2：Lua脚本原子扣减Redis库存
```
Redis执行Lua脚本：
1. 读取库存：GET seckill:stock:1 → 10000
2. 判断库存：10000 >= 1？是
3. 扣减库存：DECRBY seckill:stock:1 1 → 9999
4. 返回剩余库存：9999

如果库存不足 → 返回0 → 直接返回"库存不足"（功能4：库存不足拦截）
```

#### 步骤6.3：标记用户已秒杀
```
Redis执行：SET seckill:user:1002:1 "1"
```

#### 步骤6.4：生成订单号
```
订单号 = "SK" + 时间戳 + 用户ID + 商品ID
例如：SK177048864772010021
```

#### 步骤6.5：发送RocketMQ消息
```
发送到Topic：seckill-topic
消息内容：{userId:1002, productId:1, quantity:1}
```

#### 步骤6.6：返回"秒杀成功"
```
返回给用户：
{
  "code": 200,
  "message": "秒杀成功，请等待支付",
  "data": "SK177048864772010021"
}

用户等待时间：15ms
```

**涉及表：** 无  
**涉及Redis：** 
- seckill:user:1002:1（写）
- seckill:stock:1（更新：10000 → 9999）

---

## 阶段三：订单创建阶段（异步处理，用户无感知）

### 第7步：RocketMQ推送消息给Consumer（2秒后）

### 第8步：seckill-consumer处理订单（200ms）

#### 步骤8.1：查询商品信息
```
SQL：SELECT * FROM tb_seckill_product WHERE id=1;
查到：
- product_name: iPhone 15 Pro 256GB
- stock: 10000
- price: 6999
- version: 0
```

#### 步骤8.2：扣减MySQL库存（乐观锁）
```
SQL：
UPDATE tb_seckill_product 
SET stock = stock - 1, 
    version = version + 1 
WHERE id = 1 AND version = 0;

执行结果：
- 影响行数：1（成功）
- stock：10000 → 9999
- version：0 → 1

如果影响行数=0（失败）→ 说明被其他线程抢先更新了
```

#### 步骤8.3：创建订单
```
SQL：
INSERT INTO tb_seckill_order (
    order_no, user_id, product_id, product_name, 
    price, quantity, status, create_time
) VALUES (
    'SK177048864772010021',
    1002,
    1,
    'iPhone 15 Pro 256GB',
    6999.00,
    1,
    0,  -- 0=待支付
    '2026-02-09 10:01:00'
);
```

#### 步骤8.4：记录库存扣减日志
```
SQL：
INSERT INTO tb_stock_log (
    order_no, product_id, product_name, quantity, 
    before_stock, after_stock, type, create_time
) VALUES (
    'SK177048864772010021',
    1,
    'iPhone 15 Pro 256GB',
    1,
    10000,  -- 扣减前库存
    9999,   -- 扣减后库存
    1,      -- 1=扣减
    '2026-02-09 10:01:00'
);
```

#### 步骤8.5：记录用户秒杀记录
```
SQL：
INSERT INTO tb_user_seckill (
    user_id, product_id, order_no, create_time
) VALUES (
    1002,
    1,
    'SK177048864772010021',
    '2026-02-09 10:01:00'
);

注意：这个表有唯一索引 uk_user_product (user_id, product_id)
如果用户重复秒杀，这里会报错（第2道防线）
```

**涉及表：**
- tb_seckill_product（更新：stock, version）
- tb_seckill_order（插入1条）
- tb_stock_log（插入1条）
- tb_user_seckill（插入1条）

---

## 阶段四：数据一致性验证

### 第9步：验证数据一致性

#### Redis数据：
```
GET seckill:stock:1
→ 9999

EXISTS seckill:user:1002:1
→ 1
```

#### MySQL数据：
```
-- 商品库存
SELECT stock, version FROM tb_seckill_product WHERE id=1;
→ stock=9999, version=1

-- 订单
SELECT * FROM tb_seckill_order WHERE order_no='SK177048864772010021';
→ 1条记录

-- 库存日志
SELECT * FROM tb_stock_log WHERE order_no='SK177048864772010021';
→ 1条记录（before_stock=10000, after_stock=9999）

-- 用户记录
SELECT * FROM tb_user_seckill WHERE user_id=1002 AND product_id=1;
→ 1条记录
```

#### 一致性检查：
- ✅ Redis库存 = MySQL库存 = 9999
- ✅ 订单、日志、用户记录都已创建
- ✅ 数据完全一致

---

## 完整流程时间线

| 时间点 | 操作 | Redis库存 | MySQL库存 | 订单数 | 用户看到 |
|--------|------|-----------|-----------|--------|----------|
| T0 | 库存预热 | 10000 | 10000 | 0 | - |
| T1 | 用户1002秒杀 | 9999 | 10000 | 0 | "秒杀成功"（15ms） |
| T2（2秒后） | Consumer处理 | 9999 | 9999 | 1 | 无感知 |

---

## 表之间的数据流转

```
第1步：tb_seckill_product（商品表）
    ├─ 预热时：读取 stock=10000 → 写入Redis
    └─ 消费时：更新 stock=9999, version=1
         ↓
第2步：tb_seckill_order（订单表）
    └─ 插入订单：order_no, user_id, product_id, price...
         ↓
第3步：tb_stock_log（库存日志表）
    └─ 插入日志：order_no, before_stock=10000, after_stock=9999
         ↓
第4步：tb_user_seckill（用户记录表）
    └─ 插入记录：user_id, product_id, order_no
```

---

## 防超卖和防重复机制

### 防超卖的3道防线
1. **Redis Lua脚本**（第6步）：原子操作，绝对不超卖
2. **MySQL乐观锁**（第8步）：version字段，防止并发更新
3. **库存日志**（第8步）：记录每次扣减，方便排查问题

### 防重复秒杀的2道防线
1. **Redis防线**（第6步）：seckill:user:{userId}:{productId}，秒杀前检查
2. **MySQL防线**（第8步）：tb_user_seckill表，唯一索引uk_user_product

---

## 四张表的详细关系

### 表1：tb_seckill_product（秒杀商品表）
```sql
CREATE TABLE tb_seckill_product (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    product_name VARCHAR(100) NOT NULL,
    stock INT NOT NULL DEFAULT 0,           -- MySQL真实库存
    price DECIMAL(10,2) NOT NULL,
    original_price DECIMAL(10,2) NOT NULL,
    start_time DATETIME NOT NULL,
    end_time DATETIME NOT NULL,
    status TINYINT NOT NULL DEFAULT 0,      -- 0=未开始 1=进行中 2=已结束
    version INT NOT NULL DEFAULT 0,         -- 乐观锁版本号
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

**核心字段：**
- `stock`：MySQL真实库存，用于最终一致性
- `version`：乐观锁版本号，防止并发更新

---

### 表2：tb_seckill_order（秒杀订单表）
```sql
CREATE TABLE tb_seckill_order (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_no VARCHAR(50) NOT NULL UNIQUE,   -- 订单号（唯一索引）
    user_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,             -- 关联 tb_seckill_product.id
    product_name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    quantity INT NOT NULL DEFAULT 1,
    status TINYINT NOT NULL DEFAULT 0,      -- 0=待支付 1=已支付 -1=已取消
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    pay_time DATETIME
);
```

**关系：**
- `product_id` → 关联 `tb_seckill_product.id`（一对多）

---

### 表3：tb_stock_log（库存扣减日志表）
```sql
CREATE TABLE tb_stock_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_no VARCHAR(50) NOT NULL,          -- 关联 tb_seckill_order.order_no
    product_id BIGINT NOT NULL,             -- 关联 tb_seckill_product.id
    product_name VARCHAR(100) NOT NULL,
    quantity INT NOT NULL,
    before_stock INT NOT NULL,              -- 扣减前库存
    after_stock INT NOT NULL,               -- 扣减后库存
    type TINYINT NOT NULL,                  -- 1=扣减 2=回滚
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

**关系：**
- `order_no` → 关联 `tb_seckill_order.order_no`（一对一）
- `product_id` → 关联 `tb_seckill_product.id`

---

### 表4：tb_user_seckill（用户秒杀记录表）
```sql
CREATE TABLE tb_user_seckill (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,             -- 关联 tb_seckill_product.id
    order_no VARCHAR(50) NOT NULL,          -- 关联 tb_seckill_order.order_no
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY uk_user_product (user_id, product_id)  -- 唯一索引，防止重复秒杀
);
```

**关系：**
- `product_id` → 关联 `tb_seckill_product.id`
- `order_no` → 关联 `tb_seckill_order.order_no`（一对一）
- `uk_user_product`：唯一索引，防止一个用户重复秒杀同一个商品

---

## 表关系图

```
tb_seckill_product（商品表）
    ├─ id=1, product_name="iPhone 15 Pro", stock=10000, version=0
    │
    ↓ product_id（一对多）
    │
tb_seckill_order（订单表）
    ├─ order_no="SK177...", user_id=1002, product_id=1, status=0
    │
    ├─→ order_no（一对一）
    │   │
    │   tb_stock_log（库存日志表）
    │       └─ order_no="SK177...", before_stock=10000, after_stock=9999
    │
    └─→ order_no（一对一）
        │
        tb_user_seckill（用户记录表）
            └─ user_id=1002, product_id=1, order_no="SK177..."
            └─ 唯一索引：uk_user_product (user_id, product_id)
```

---

## ER图（实体关系图）

```
┌─────────────────────────┐
│  tb_seckill_product     │
│  （秒杀商品表）          │
├─────────────────────────┤
│  PK: id                 │
│  stock（库存）           │
│  version（乐观锁）       │
└─────────────────────────┘
            │
            │ 1:N
            │ product_id
            ↓
┌─────────────────────────┐
│  tb_seckill_order       │
│  （秒杀订单表）          │
├─────────────────────────┤
│  PK: id                 │
│  UK: order_no           │
│  FK: product_id         │
│  user_id                │
│  status（订单状态）      │
└─────────────────────────┘
            │
            ├─────────────────────┐
            │ 1:1                 │ 1:1
            │ order_no            │ order_no
            ↓                     ↓
┌─────────────────────────┐  ┌─────────────────────────┐
│  tb_stock_log           │  │  tb_user_seckill        │
│  （库存日志表）          │  │  （用户记录表）          │
├─────────────────────────┤  ├─────────────────────────┤
│  PK: id                 │  │  PK: id                 │
│  FK: order_no           │  │  FK: order_no           │
│  FK: product_id         │  │  FK: product_id         │
│  before_stock           │  │  user_id                │
│  after_stock            │  │  UK: (user_id,          │
│  type（1=扣减 2=回滚）   │  │      product_id)        │
└─────────────────────────┘  └─────────────────────────┘
```

---

## 核心技术点

### 1. Redis Lua脚本（防超卖）
```lua
-- stock.lua
local stock = redis.call('GET', KEYS[1])
if not stock then return -1 end
stock = tonumber(stock)
if stock < tonumber(ARGV[1]) then return 0 end
redis.call('DECRBY', KEYS[1], ARGV[1])
return stock - tonumber(ARGV[1])
```

**为什么需要Lua脚本？**
- 不用Lua：读、判断、扣减三步分开，并发时会超卖
- 用Lua：三步合成一个原子操作，绝对不超卖

---

### 2. RocketMQ削峰填谷
```
用户请求（10万并发）
    ↓
Redis扣库存（15ms）→ 发MQ消息 → 返回"秒杀成功"
    ↓
RocketMQ（削峰填谷）
    ↓ 10万请求 → 1000个/秒慢慢消费
Consumer异步处理（200ms）
    ├─ 扣MySQL库存
    ├─ 创建订单
    └─ 记录日志
```

**为什么需要MQ？**
- 不用MQ：用户等200ms，数据库崩溃
- 用MQ：用户等15ms，数据库压力小

---

### 3. MySQL乐观锁（防超卖）
```sql
UPDATE tb_seckill_product 
SET stock = stock - 1, 
    version = version + 1 
WHERE id = 1 AND version = 0;
```

**原理：**
- 线程A执行：`WHERE version=0` → 成功，version变成1
- 线程B执行：`WHERE version=0` → 失败，因为version已经是1了
- 结果：只有一个线程能扣减成功，防止超卖

---

## 总结

### 核心流程（9步）
1. 启动环境（MySQL、Redis、RocketMQ）
2. 初始化数据（4张表、3个商品）
3. 启动服务（seckill-service、seckill-consumer）
4. 库存预热（MySQL → Redis）
5. 用户秒杀（点击"立即抢购"）
6. 秒杀处理（Redis扣库存 + 发MQ，15ms）
7. MQ推送（2秒后）
8. 订单创建（扣MySQL库存 + 创建订单 + 记录日志，200ms）
9. 数据一致性验证（Redis = MySQL）

### 4张表的作用
1. **tb_seckill_product**：存储商品信息和真实库存
2. **tb_seckill_order**：存储秒杀订单
3. **tb_stock_log**：记录库存扣减日志，方便排查问题
4. **tb_user_seckill**：记录用户秒杀记录，防止重复秒杀

### 防超卖的3道防线
1. Redis Lua脚本：原子操作
2. MySQL乐观锁：version字段
3. 库存日志：记录每次扣减

### 防重复秒杀的2道防线
1. Redis防线：seckill:user:{userId}:{productId}
2. MySQL防线：tb_user_seckill表唯一索引

---

**文档版本：** v1.0  
**最后更新：** 2026-02-09  
**作者：** Kiro AI
