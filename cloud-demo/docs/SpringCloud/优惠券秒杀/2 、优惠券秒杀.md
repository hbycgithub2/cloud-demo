阶段一：库存预热 
    1、查询秒杀的商品，
    2、写入Redis缓存中（key商品id  value 库存数量）
        ↓
阶段二：用户秒杀阶段
3、用户点击"立即抢购"
         ↓
4、Lua脚本原子扣减Redis库存
4.1. 读取库存：GET seckill:stock:1 → 10000（通过缓存key 商品id获取库存数量）
4.2. 判断库存：10000 >= 1？是（判断库存是否大于等于1）
4.3. 扣减库存：DECRBY seckill:stock:1 1 → 9999
4.4. 返回剩余库存：9999
        ↓
5：标记用户已秒杀
Redis执行：SET seckill:user:1002:1 "1"（将用户id作为key value 库存数放到redis缓存）

MQ的3大核心好处
削峰：大量请求瞬间涌入，MQ缓冲后慢慢消费落表，MySQL不崩溃

异步：发完消息立即返回，用户不用等订单创建

解耦：秒杀服务Redis操作完直接返回结果，订单服务从MQ消费，互不依赖互不影响        ↓
6.4：生成订单号：订单号 = "SK" + 时间戳 + 用户ID + 商品ID
↓
  步骤6.5：发送RocketMQ消息
   

 rocketMQTemplate.convertAndSend("seckill-topic", message);
发送到Topic：seckill-topic
消息内容：{userId:1002, productId:1, quantity:1}

 步骤6.6：返回"秒杀成功"
 用户等待时间：15ms（只等Redis扣库存+发MQ）

RocketMQ作用：

接收消息并持久化到磁盘
削峰：10万请求瞬间涌入，MQ慢慢推送给Consumer



 ## 阶段三：订单创建阶段（异步处理，用户无感知）

### 第7步：RocketMQ推送消息给Consumer（2秒后）
        Consumer监听订阅RocketMQ推送消息


### 第8步：seckill-consumer处理订单（200ms）
查询商品信息 → 扣减MySQL库存（乐观锁）→ 创建订单 → 记录库存日志 → 记录用户秒杀记录

步骤8.1：查询商品信息获取版本号
        ↓
步骤8.2：扣减MySQL库存（乐观锁）
```sql
UPDATE tb_seckill_product 
SET stock = stock - 1, version = version + 1 
WHERE id = 1 AND version = 0;
```
乐观锁通过版本号机制实现并发控制：读取数据时获取version，更新时WHERE条件校验version是否一致，一致则更新成功并递增version，不一致则更新商品库存数-1失败，利用数据库WHERE条件的原子性保证同一时刻只有一个线程能通过version校验。


如果总失败了，不是会影响并发性能效果
因为MySQL乐观锁更新是在Consumer异步处理，用户已经收到"秒杀成功"了（15ms就返回了），重试是后台慢慢重试，用户无感知。

而且Redis Lua脚本已经扣减了库存，MySQL只是做最终一致性保障，即使重试几次也不影响用户体验，只是Consumer处理时间从200ms变成300ms，但用户早就拿到结果了。

核心：用户体验靠Redis（快），MySQL靠MQ异步处理（慢但准确），互不影响。


↓
#### 步骤8.3：创建订单
核心： 从MQ消息中拿到用户ID和商品ID，查询商品信息获取商品名和价格，生成订单号，组装成一条订单记录插入数据库。

***创建订单流程：
生成订单号：SK + 时间戳 + 用户ID + 商品ID，生成唯一订单号SK177048864772010021
组装订单数据：用户ID 1002、商品ID 1、商品名iPhone 15 Pro 256GB、价格6999、数量1、状态0（待支付）、创建时间
插入订单表：执行INSERT语句，把订单数据写入tb_seckill_order表
返回结果：插入成功，订单创建完成
核心： 从MQ消息中拿到用户ID和商品ID，查询商品信息获取商品名和价格，生成订单号，组装成一条订单记录插入数据库。

↓
#### 步骤8.4：记录库存扣减日志（记录库存变化、排查库存问题，防超卖验证，库存审计）
```
SQL：
INSERT INTO tb_stock_log (
    order_no, product_id, product_name, quantity, 
    before_stock, after_stock, type, create_time
) VALUES (
    'SK177048864772010021',
    1,
    'iPhone 15 Pro 256GB',
    1,
    10000,  -- 扣减前库存
    9999,   -- 扣减后库存
    1,      -- 1=扣减
    '2026-02-09 10:01:00'
);
```
↓
步骤8.5：记录用户秒杀记录（记录用户秒杀行为：哪个用户秒杀了哪个商品）

把用户ID、商品ID、订单号记录到秒杀记录表，利用唯一索引uk_user_product保证一个用户只能秒杀同一商品一次，防止重复秒杀。
防重复秒杀（第2道防线）：如果Redis防线被绕过，MySQL唯一索引会拦截重复秒杀
（用户id 和 商品id的组合唯一索引，只能插入一次拦截重复秒杀）


***记录用户秒杀记录流程：
组装记录数据：用户ID 1002、商品ID 1、订单号SK177048864772010021、创建时间
插入记录表：执行INSERT语句，把数据写入tb_user_seckill表
唯一索引校验：表有唯一索引uk_user_product(user_id, product_id)，如果用户重复秒杀同一商品会插入失败
防重复作用：这是防重复秒杀的第2道防线（MySQL防线），第1道是Redis防线
核心： 把用户ID、商品ID、订单号记录到tb_user_seckill表，利用唯一索引uk_user_product保证一个用户只能秒杀同一商品一次，防止重复秒杀。


两张表的区别：

tb_stock_log（库存日志表）：

记录库存变化：before_stock=10000，after_stock=9999
关注点：商品库存扣减了多少
用途：排查库存问题，防超卖验证，库存审计
tb_user_seckill（用户秒杀记录表）：

记录用户秒杀行为：哪个用户秒杀了哪个商品
关注点：用户和商品的关系
用途：防止用户重复秒杀（唯一索引），查询用户秒杀记录
举例说明：

tb_stock_log：商品1的库存从10000变成9999（关注库存）
tb_user_seckill：用户1002秒杀了商品1（关注用户行为）
核心： tb_stock_log记录"库存怎么变的"，tb_user_seckill记录"谁秒杀了什么"，一个关注库存，一个关注用户，用途不同。

**涉及表：**
- tb_seckill_product（更新：stock, version）
- tb_seckill_order（插入1条）
- tb_stock_log（插入1条）
- tb_user_seckill（插入1条）



## 表之间的数据流转

```
第1步：tb_seckill_product（商品表）
    ├─ 预热时：读取 stock=10000 → 写入Redis
    └─ 消费时：更新 stock=9999, version=1
         ↓
第2步：tb_seckill_order（订单表）
    └─ 插入订单：order_no, user_id, product_id, price...
         ↓
第3步：tb_stock_log（库存日志表）
    └─ 插入日志：order_no, before_stock=10000, after_stock=9999
         ↓
第4步：tb_user_seckill（用户记录表）
    └─ 插入记录：user_id, product_id, order_no
```



### 防超卖的3道防线
1. **Redis Lua脚本**（第6步）：原子操作，绝对不超卖
2. **MySQL乐观锁**（第8步）：version字段，防止并发更新
3. **库存日志**（第8步）：记录每次扣减，方便排查问题

### 防重复秒杀的2道防线
1. **Redis防线**（第6步）：seckill:user:{userId}:{productId}，秒杀前检查
2. **MySQL防线**（第8步）：tb_user_seckill表，唯一索引uk_user_product