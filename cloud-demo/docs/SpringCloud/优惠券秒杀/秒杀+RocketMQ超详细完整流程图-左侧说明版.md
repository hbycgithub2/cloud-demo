# 秒杀+RocketMQ超详细完整流程图（左侧说明版）

> **项目：** seckill-demo + rocketmq-demo  
> **场景：** 用户秒杀iPhone 15 Pro（10000库存）  
> **目标：** 左侧加上主干流程说明，右侧详细参数解释

---

## 可视化流程图（一图看懂整个流程）

```
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                          秒杀+RocketMQ完整流程图（用户1002秒杀iPhone 15 Pro）                                        │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║ 【阶段1：用户发起秒杀请求】0ms-2ms                                                                                                  ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

【用户发送秒杀请求】

  ┌──────────┐
  │ 用户1002  │ 点击"立即抢购"按钮
  └─────┬────┘
        │
        ▼
  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤1：前端发送HTTP请求                                      │ → 用户点击按钮，前端发送POST请求到后端
  │ POST /seckill/kill                                          │
  │ {                                                           │   【入参说明】
  │   userId: 1002,        ← 用户ID                             │   userId: 1002 → 谁在秒杀？用户1002
  │   productId: 1,        ← 商品ID                             │   productId: 1 → 秒杀什么？商品1（iPhone 15 Pro）
  │   quantity: 1          ← 购买数量                           │   quantity: 1 → 秒杀几个？1个
  │ }                                                           │   【总结】3个参数告诉后端：用户1002要秒杀1个商品1
  └─────────────────────────┬───────────────────────────────────┘
                            │
                            ▼

【Controller接收请求】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤2：SeckillController接收请求                             │ → Controller接收请求，调用Service层
  │ @PostMapping("/kill")                                       │
  │ seckillService.seckill(dto)                                 │
  └─────────────────────────┬───────────────────────────────────┘   【参数说明】
                            │                                        dto → 秒杀DTO对象（包含userId:1002, productId:1, quantity:1）
                            ▼                                        @PostMapping("/kill") → 接收POST请求，路径/kill
                                                                     seckillService.seckill(dto) → 调用Service层处理秒杀逻辑
                                                                     【总结】Controller接收请求，把dto传给Service层处理

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║ 【阶段2：Redis检查和扣库存】2ms-18ms                                                                                                ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

【检查用户是否已秒杀】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤3：检查用户是否已秒杀                                    │ → Redis检查Key是否存在，防止重复秒杀（第一道防线）
  │ Redis: EXISTS seckill:user:1002:1                           │
  │ 返回：0（未秒杀，可以继续）                                  │   【Key说明】
  └─────────────────────────┬───────────────────────────────────┘   seckill:user:1002:1 → 用户1002秒杀商品1的标记
                            │                                        1002 → userId（用户ID）
                            ▼                                        1 → productId（商品ID）
                                                                     返回0 → Key不存在，用户未秒杀，可以继续
                                                                     返回1 → Key存在，用户已秒杀，直接拒绝
                                                                     【总结】Redis第一道防线，快速拦截重复秒杀

【Lua脚本原子扣库存】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤4：Lua脚本原子扣减Redis库存                              │ → Lua脚本保证原子操作，读、判断、扣减一气呵成，绝对不超卖
  │ ┌─────────────────────────────────────────────────────┐     │
  │ │ GET seckill:stock:1 → 10000                         │     │   【第1步：读】查询商品1的库存，返回10000
  │ │ 判断：10000 >= 1？true                              │     │   【第2步：判断】库存10000够不够扣1个？够！
  │ │ DECRBY seckill:stock:1 1                            │     │   【第3步：扣减】库存减1，10000-1=9999
  │ │ 结果：10000 → 9999                                  │     │   【第4步：返回】返回剩余库存9999
  │ │ 返回：9999（剩余库存）                              │     │   【总结】Lua脚本原子执行，读→判断→扣减不会被打断，绝对不超卖！
  │ └─────────────────────────────────────────────────────┘     │
  └─────────────────────────┬───────────────────────────────────┘
                            │
                            ▼

【判断扣减结果】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤5：判断扣减结果                                          │ → 判断Lua脚本返回值，9999表示扣减成功
  │ result = 9999（扣减成功）                                   │
  └─────────────────────────┬───────────────────────────────────┘   【结果说明】
                            │                                        result = 9999 → Lua脚本返回的剩余库存
                            ▼                                        9999 → 扣减成功，剩余库存9999个
                                                                     -1 → 扣减失败，库存不足
                                                                     【总结】判断Lua脚本返回值，9999表示扣减成功，可以继续

【标记用户已秒杀】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤6：标记用户已秒杀                                        │ → Redis标记用户已秒杀，下次请求直接拒绝
  │ Redis: SET seckill:user:1002:1 "1"                          │
  └─────────────────────────┬───────────────────────────────────┘   【Key说明】
                            │                                        seckill:user:1002:1 → 用户1002秒杀商品1的标记
                            ▼                                        1002 → userId（用户ID）
                                                                     1 → productId（商品ID）
                                                                     Value: "1" → 标记值（任意值都行，Key存在就表示已秒杀）
                                                                     【总结】Redis标记用户已秒杀，下次请求步骤3会检查到，直接拒绝

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║ 【阶段3：发送MQ消息】19ms-24ms                                                                                                      ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

【调用RocketMQ发送消息】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤7：调用RocketMQTemplate发送消息                          │ → 调用RocketMQ模板，发送秒杀消息到MQ
  │ rocketMQTemplate.convertAndSend("seckill-topic", dto)       │
  └─────────────────────────┬───────────────────────────────────┘   【参数说明】
                            │                                        "seckill-topic" → Topic名称，秒杀消息发送到这个Topic
                            ▼                                        dto → 消息内容（包含userId:1002, productId:1, quantity:1）
                                                                     【总结】调用RocketMQ模板，把秒杀消息发送到seckill-topic

【序列化消息】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤8：序列化消息                                            │ → 将DTO对象序列化为JSON字符串
  │ JSON: {"userId":1002,"productId":1,"quantity":1}            │
  └─────────────────────────┬───────────────────────────────────┘   【序列化说明】
                            │                                        将Java对象转换为JSON字符串，方便网络传输
                            ▼                                        userId:1002 → 用户ID
                                                                     productId:1 → 商品ID
                                                                     quantity:1 → 购买数量
                                                                     【总结】序列化后的JSON字符串可以通过网络发送给Broker

【查询NameServer路由】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤9：连接NameServer查询路由                                │ → 连接NameServer，查询Topic在哪个Broker上
  │ NameServer: 127.0.0.1:9876                                  │
  │ 返回：seckill-topic有4个Queue                               │
  └─────────────────────────┬───────────────────────────────────┘   【NameServer说明】
                            │                                        NameServer → RocketMQ的注册中心，类似微信通讯录
                            ▼                                        127.0.0.1:9876 → NameServer地址和端口
                                                                     seckill-topic → 要查询的Topic名称
                                                                     4个Queue → Topic有4个队列（Queue0-Queue3）
                                                                     【总结】NameServer告诉Producer：seckill-topic在哪个Broker上，有几个Queue

【选择Queue】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤10：选择Queue（轮询算法）                                │ → 轮询算法选择Queue0，负载均衡
  │ 选择：Queue0                                                │
  └─────────────────────────┬───────────────────────────────────┘   【选择说明】
                            │                                        轮询算法 → 第1条消息→Queue0，第2条→Queue1，第3条→Queue2，第4条→Queue3，第5条→Queue0...
                            ▼                                        Queue0 → 本次消息选择Queue0
                                                                     【总结】轮询算法保证4个Queue负载均衡，每个Queue消息数量差不多

【发送消息到Broker】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤11：发送消息到Broker                                     │ → TCP连接Broker，发送消息
  │ TCP连接：127.0.0.1:10911                                    │
  └─────────────────────────┬───────────────────────────────────┘   【连接说明】
                            │                                        TCP连接 → 可靠的网络连接，保证消息不丢失
                            ▼                                        127.0.0.1:10911 → Broker地址和端口
                                                                     【总结】通过TCP连接发送消息到Broker，保证消息可靠传输

【Broker存储消息】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤12：Broker存储消息                                       │ → Broker持久化消息到磁盘，保证不丢失
  │ ┌─────────────────────────────────────────────────────┐     │
  │ │ 写入CommitLog（顺序写，快）                         │     │   【第1步：写CommitLog】所有消息写到同一个文件，顺序写，速度快
  │ │ 同步刷盘（持久化到磁盘）                            │     │   【第2步：同步刷盘】消息写到磁盘，Broker宕机也不丢失
  │ │ 构建ConsumeQueue索引                                │     │   【第3步：构建索引】为每个Queue构建索引，Consumer快速查找
  │ └─────────────────────────────────────────────────────┘     │   【总结】Broker三步保证消息可靠：写文件→刷盘→建索引
  └─────────────────────────┬───────────────────────────────────┘
                            │
                            ▼

【Broker返回结果】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤13：Broker返回SendResult                                 │ → Broker返回发送结果，包含消息ID
  │ {sendStatus:"SEND_OK", msgId:"C0A8..."}                     │
  └─────────────────────────┬───────────────────────────────────┘   【返回结果说明】
                            │                                        sendStatus:"SEND_OK" → 发送成功
                            ▼                                        msgId:"C0A8..." → 消息ID，全局唯一，可追踪
                                                                     【总结】Broker告诉Producer：消息已成功保存，消息ID是C0A8...

【返回用户秒杀成功】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤14：生成订单号并返回用户                                 │ → 生成订单号，返回"秒杀成功"给用户
  │ 订单号：SK177048864772010021                                │
  │ 返回：{"code":200, "message":"秒杀成功"}                     │
  └─────────────────────────┬───────────────────────────────────┘   【返回说明】
                            │                                        订单号：SK177048864772010021 → 唯一订单号，用户可以查询订单
                            ▼                                        code:200 → 成功状态码
                                                                     message:"秒杀成功" → 提示信息
                                                                     【总结】生成订单号，返回"秒杀成功"给用户，用户只等了22ms

  ┌──────────┐
  │ 用户1002  │ 看到"秒杀成功，请等待支付"（22ms）                → 用户只等22ms，体验极好！
  └──────────┘                                                       【用户体验说明】
                                                                     22ms → 用户从点击到看到"秒杀成功"只等了22ms
                                                                     体验极好 → 用户感觉秒杀很快，不用等待
                                                                     【总结】用户只等Redis+MQ（22ms），订单创建异步处理，用户无感知

═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
                                        用户不再等待，后台异步处理（约2秒后）
═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║ 【阶段4：Broker推送消息】~2000ms                                                                                                    ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

【Broker检测新消息】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤15：Broker检测到新消息                                   │ → Broker每隔1秒检查Queue，发现新消息
  │ 发现：seckill-topic的Queue0有新消息                         │
  └─────────────────────────┬───────────────────────────────────┘   【检测说明】
                            │                                        Broker每隔1秒 → 定时检查Queue是否有新消息
                            ▼                                        seckill-topic的Queue0 → 检测到Queue0有新消息
                                                                     【总结】Broker定时检查Queue，发现新消息后准备推送给Consumer

【查询订阅关系】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤16：Broker查询订阅关系                                   │ → 查询哪些Consumer订阅了这个Topic
  │ 查到：seckill-consumer订阅了该Topic                         │
  └─────────────────────────┬───────────────────────────────────┘   【订阅关系说明】
                            │                                        Broker查询 → 查询哪些Consumer订阅了seckill-topic
                            ▼                                        seckill-consumer → 查到seckill-consumer订阅了该Topic
                                                                     【总结】Broker查询订阅关系，确定要推送给哪个Consumer

【Broker推送消息】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤17：Broker推送消息给Consumer                             │ → Push模式，Broker主动推送，削峰填谷（最多1000条/秒）
  │ Push模式：最多1000条/秒（削峰填谷）                          │
  │ TCP连接：127.0.0.1:8093                                     │
  └─────────────────────────┬───────────────────────────────────┘   【推送说明】
                            │                                        Push模式 → Broker主动推送消息给Consumer（不是Consumer拉取）
                            ▼                                        最多1000条/秒 → 削峰填谷，10万请求→1000条/秒慢慢消费
                                                                     127.0.0.1:8093 → Consumer地址和端口
                                                                     【总结】Broker主动推送消息，削峰填谷，保护MySQL不崩溃

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║ 【阶段5：Consumer消费消息】~2000ms-~2200ms                                                                                         ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

【Consumer接收消息】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤18：Consumer监听器接收消息                               │ → Consumer监听器自动接收消息，开始处理
  │ SeckillOrderConsumer.onMessage(dto)                         │
  └─────────────────────────┬───────────────────────────────────┘   【监听器说明】
                            │                                        SeckillOrderConsumer → Consumer类名
                            ▼                                        onMessage(dto) → 监听器方法，自动接收消息
                                                                     dto → 消息内容（userId:1002, productId:1, quantity:1）
                                                                     【总结】Consumer监听器自动接收消息，开始异步处理订单创建

【查询商品信息】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤19：查询商品信息                                         │ → 查询商品价格、库存、版本号（乐观锁用）
  │ SQL: SELECT * FROM tb_seckill_product WHERE id=1            │
  │ 查到：iPhone 15 Pro, stock=10000, price=6999, version=0    │
  └─────────────────────────┬───────────────────────────────────┘   【SQL说明】
                            │                                        SELECT * → 查询所有字段
                            ▼                                        FROM tb_seckill_product → 从秒杀商品表查询
                                                                     WHERE id=1 → 查询商品ID=1（iPhone 15 Pro）
                                                                     【查询结果】
                                                                     stock=10000 → 当前库存10000个
                                                                     price=6999 → 商品价格6999元
                                                                     version=0 → 乐观锁版本号0（用于防止并发超卖）
                                                                     【总结】查询商品信息，获取价格、库存、版本号，为后续扣库存做准备

【扣减MySQL库存】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤20：扣减MySQL库存（乐观锁）                              │ → 乐观锁防止超卖，WHERE version=0，只有一个线程能成功
  │ SQL: UPDATE tb_seckill_product                              │
  │      SET stock=stock-1, version=version+1                   │
  │      WHERE id=1 AND version=0                               │
  │ 结果：stock: 10000→9999, version: 0→1                       │
  │ 影响行数：1（成功）                                          │
  └─────────────────────────┬───────────────────────────────────┘   【SQL说明】
                            │                                        UPDATE tb_seckill_product → 更新秒杀商品表
                            ▼                                        SET stock=stock-1 → 库存减1（10000-1=9999）
                                                                     SET version=version+1 → 版本号加1（0+1=1）
                                                                     WHERE id=1 → 更新商品ID=1
                                                                     WHERE version=0 → 乐观锁关键！只有version=0才能更新
                                                                     【乐观锁原理】
                                                                     线程A执行：version=0，更新成功，version变成1
                                                                     线程B执行：version=0，但version已经是1了，更新失败
                                                                     【总结】乐观锁保证只有一个线程能扣减库存，绝对不超卖！

【创建订单】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤21：创建订单                                             │ → 插入订单记录，status=0（待支付）
  │ SQL: INSERT INTO tb_seckill_order                           │
  │      VALUES ('SK177...', 1002, 1, 'iPhone 15 Pro',         │
  │              6999, 1, 0, '2024-02-09...')                   │
  └─────────────────────────┬───────────────────────────────────┘   【SQL说明】
                            │                                        INSERT INTO tb_seckill_order → 插入秒杀订单表
                            ▼                                        VALUES → 插入的值
                                                                     'SK177...' → 订单号（唯一标识）
                                                                     1002 → 用户ID（用户1002）
                                                                     1 → 商品ID（商品1，iPhone 15 Pro）
                                                                     'iPhone 15 Pro' → 商品名称
                                                                     6999 → 商品价格（6999元）
                                                                     1 → 购买数量（1个）
                                                                     0 → 订单状态（0=待支付，1=已支付，-1=已取消）
                                                                     '2024-02-09...' → 创建时间
                                                                     【总结】创建订单记录，用户可以查看订单、支付订单

【记录库存日志】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤22：记录库存扣减日志                                     │ → 记录库存变化，方便排查问题（10000→9999）
  │ SQL: INSERT INTO tb_stock_log                               │
  │      VALUES ('SK177...', 1, 'iPhone 15 Pro', 1,            │
  │              10000, 9999, 1, ...)                           │
  └─────────────────────────┬───────────────────────────────────┘   【SQL说明】
                            │                                        INSERT INTO tb_stock_log → 插入库存日志表
                            ▼                                        VALUES → 插入的值
                                                                     'SK177...' → 订单号（哪个订单扣的库存）
                                                                     1 → 商品ID（扣的是商品1的库存）
                                                                     'iPhone 15 Pro' → 商品名称
                                                                     1 → 扣减数量（扣了1个）
                                                                     10000 → 扣减前库存（原来有10000个）
                                                                     9999 → 扣减后库存（现在还剩9999个）
                                                                     1 → 操作类型（1=扣减，2=回滚）
                                                                     【总结】记录库存变化，方便排查问题，防止超卖

【记录用户秒杀记录】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤23：记录用户秒杀记录                                     │ → 插入用户秒杀记录，唯一索引防止重复秒杀（第二道防线）
  │ SQL: INSERT INTO tb_user_seckill                            │
  │      VALUES (1002, 1, 'SK177...', ...)                      │
  │ 唯一索引：uk_user_product(user_id, product_id)             │
  └─────────────────────────┬───────────────────────────────────┘   【SQL说明】
                            │                                        INSERT INTO tb_user_seckill → 插入用户秒杀记录表
                            ▼                                        VALUES → 插入的值
                                                                     1002 → 用户ID（用户1002）
                                                                     1 → 商品ID（商品1）
                                                                     'SK177...' → 订单号
                                                                     【唯一索引说明】
                                                                     uk_user_product(user_id, product_id) → 唯一索引
                                                                     保证一个用户只能秒杀一次同一商品
                                                                     如果用户1002再次秒杀商品1，INSERT会失败（唯一索引冲突）
                                                                     【总结】MySQL第二道防线，防止重复秒杀（Redis是第一道防线）

【返回ACK给Broker】

  ┌─────────────────────────────────────────────────────────────┐
  │ 步骤24：返回ACK给Broker                                      │ → Consumer返回ACK，Broker删除消息（如果失败，重试16次）
  │ Broker收到ACK → 删除消息                                    │
  │ （如果失败，重试最多16次）                                   │
  └─────────────────────────┬───────────────────────────────────┘   【ACK说明】
                            │                                        ACK = Acknowledgement（确认）
                            ▼                                        Consumer告诉Broker："我已经消费成功了，你可以删除这条消息了"
                                                                     【如果消费失败】
                                                                     Consumer抛出异常 → Broker不删除消息 → 触发重试
                                                                     重试次数：最多16次
                                                                     重试间隔：10s、30s、1m、2m、3m...2h
                                                                     超过16次 → 进入死信队列（需要人工处理）
                                                                     【总结】ACK机制保证消息不丢失，消费失败会自动重试

  ┌──────────────────────────────────────────────────────────────┐
  │  完成！订单创建成功（~2200ms）                                │ → 后台处理完成，用户无感知（用户只等了22ms）
  │  用户无感知，后台已完成所有操作                               │
  └──────────────────────────────────────────────────────────────┘   【完成说明】
                                                                     ~2200ms → 从用户点击到订单创建完成，总共2200ms
                                                                     用户只等了22ms → 用户只等Redis+MQ（22ms），订单创建异步处理（2200ms）
                                                                     用户无感知 → 用户看到"秒杀成功"后就不用等了，后台慢慢处理
                                                                     【总结】异步处理提升用户体验，用户只等22ms，后台慢慢处理2200ms
```

---

**完成时间：** 2024-02-09  
**总步骤数：** 24步  
**总耗时：** 2200ms（用户只等22ms）



【用户发送秒杀请求】
【Controller接收请求】
【检查用户是否已秒杀】
【Lua脚本原子扣库存】
【判断扣减结果】
【标记用户已秒杀】
【调用RocketMQ发送消息】
【序列化消息】
【查询NameServer路由】
【选择Queue】
【发送消息到Broker】
【Broker存储消息】
【Broker返回结果】
【返回用户秒杀成功】
【Broker检测新消息】
【查询订阅关系】
【Broker推送消息】
【Consumer接收消息】
【查询商品信息】
【扣减MySQL库存】
【创建订单】
【记录库存日志】
【记录用户秒杀记录】
【返回ACK给Broker】
