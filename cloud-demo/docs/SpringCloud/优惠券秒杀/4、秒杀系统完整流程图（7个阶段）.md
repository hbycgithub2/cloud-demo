# 秒杀系统完整流程图（7个阶段）

> **项目位置：** D:\code\cloud-demo\cloud-demo\seckill-demo  
> **技术栈：** Spring Boot + Redis + RocketMQ + MySQL + MyBatis  
> **核心目标：** 掌握秒杀系统7个阶段完整流程

---

## 秒杀系统完整流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                        阶段一：准备阶段                          │
└─────────────────────────────────────────────────────────────────┘
                                ↓
                    运营人员点击"库存预热"
                                ↓
                    查询MySQL：stock=10000
                                ↓
                    写入Redis：SET seckill:stock:1 10000
                                ↓
                        返回"预热成功"

┌─────────────────────────────────────────────────────────────────┐
│                    阶段二：用户秒杀（15ms）                      │
└─────────────────────────────────────────────────────────────────┘
                                ↓
                    用户1002点击"立即抢购"
                                ↓
                ┌───────────────────────────────┐
                │   seckill-service处理         │
                ├───────────────────────────────┤
                │ 1. 检查用户是否已秒杀         │
                │    EXISTS seckill:user:1002:1 │
                │    → 返回0（未秒杀）          │
                ├───────────────────────────────┤
                │ 2. Lua脚本扣减Redis库存       │
                │    GET seckill:stock:1 → 10000│
                │    判断：10000 >= 1？是       │
                │    DECRBY seckill:stock:1 1   │
                │    → 库存变成9999             │
                ├───────────────────────────────┤
                │ 3. 标记用户已秒杀             │
                │    SET seckill:user:1002:1 "1"│
                ├───────────────────────────────┤
                │ 4. 生成订单号                 │
                │    SK177048864772010021       │
                ├───────────────────────────────┤
                │ 5. 发送RocketMQ消息 ← 核心    │
                │    Topic: seckill-topic       │
                │    Message: {userId, productId}│
                ├───────────────────────────────┤
                │ 6. 返回"秒杀成功"             │
                │    用户等待：15ms             │
                └───────────────────────────────┘
                                ↓
                        【RocketMQ消息队列】
                        持久化消息到磁盘
                        削峰：10万 → 1000/秒

┌─────────────────────────────────────────────────────────────────┐
│              阶段三：订单创建（200ms，用户无感知）               │
└─────────────────────────────────────────────────────────────────┘
                                ↓
                    RocketMQ推送消息（2秒后）
                                ↓
                ┌───────────────────────────────┐
                │  seckill-consumer处理         │
                ├───────────────────────────────┤
                │ 1. 查询商品信息               │
                │    SELECT * FROM              │
                │    tb_seckill_product         │
                │    → stock=10000, version=0   │
                ├───────────────────────────────┤
                │ 2. 扣减MySQL库存（乐观锁）    │
                │    UPDATE tb_seckill_product  │
                │    SET stock=stock-1,         │
                │        version=version+1      │
                │    WHERE id=1 AND version=0   │
                │    → stock变成9999, version=1 │
                ├───────────────────────────────┤
                │ 3. 创建订单                   │
                │    INSERT INTO                │
                │    tb_seckill_order           │
                │    → 订单号SK177...           │
                ├───────────────────────────────┤
                │ 4. 记录库存日志               │
                │    INSERT INTO tb_stock_log   │
                │    → before=10000, after=9999 │
                ├───────────────────────────────┤
                │ 5. 记录用户秒杀记录           │
                │    INSERT INTO                │
                │    tb_user_seckill            │
                │    → 唯一索引防重复           │
                └───────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    阶段四：数据一致性验证                        │
└─────────────────────────────────────────────────────────────────┘
                                ↓
                ┌───────────────────────────────┐
                │  Redis数据                    │
                │  seckill:stock:1 = 9999 ✅    │
                │  seckill:user:1002:1 = 1 ✅   │
                └───────────────────────────────┘
                                ↓
                ┌───────────────────────────────┐
                │  MySQL数据                    │
                │  商品库存 = 9999 ✅           │
                │  订单已创建 ✅                │
                │  库存日志已记录 ✅            │
                │  用户记录已创建 ✅            │
                └───────────────────────────────┘
                                ↓
                    ✅ 数据完全一致

┌─────────────────────────────────────────────────────────────────┐
│                    阶段五：支付流程（可选）                      │
└─────────────────────────────────────────────────────────────────┘
                                ↓
                    用户收到"秒杀成功"提示
                                ↓
                    点击"立即支付"按钮
                                ↓
                ┌───────────────────────────────┐
                │  支付服务处理                 │
                ├───────────────────────────────┤
                │ 1. 查询订单状态               │
                │    status=0（待支付）         │
                ├───────────────────────────────┤
                │ 2. 调用支付接口               │
                │    微信支付/支付宝            │
                ├───────────────────────────────┤
                │ 3. 更新订单状态               │
                │    status=1（已支付）         │
                └───────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                阶段六：超时取消（延迟消息）                      │
└─────────────────────────────────────────────────────────────────┘
                                ↓
                    秒杀成功时发送延迟消息
                                ↓
                    RocketMQ延迟30分钟
                                ↓
                ┌───────────────────────────────┐
                │  30分钟后Consumer处理         │
                ├───────────────────────────────┤
                │ 1. 查询订单状态               │
                │    SELECT status FROM         │
                │    tb_seckill_order           │
                ├───────────────────────────────┤
                │ 2. 如果status=0（未支付）     │
                │    → 取消订单                 │
                │    → 回滚Redis库存+1          │
                │    → 删除用户秒杀标记         │
                ├───────────────────────────────┤
                │ 3. 如果status=1（已支付）     │
                │    → 不处理                   │
                └───────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    阶段七：异常处理流程                          │
└─────────────────────────────────────────────────────────────────┘

【场景1：Consumer消费失败】
                                ↓
                    MySQL临时故障/网络超时
                                ↓
                    RocketMQ自动重试
                                ↓
                ┌───────────────────────────────┐
                │  重试机制                     │
                ├───────────────────────────────┤
                │ 第1次失败 → 10秒后重试        │
                │ 第2次失败 → 30秒后重试        │
                │ 第3次失败 → 1分钟后重试       │
                │ ...                           │
                │ 第16次失败 → 进入死信队列     │
                └───────────────────────────────┘
                                ↓
                ┌───────────────────────────────┐
                │  死信队列处理                 │
                ├───────────────────────────────┤
                │ 1. 记录到数据库               │
                │ 2. 发送告警通知               │
                │ 3. 人工介入处理               │
                └───────────────────────────────┘

【场景2：Redis宕机】
                                ↓
                    用户秒杀请求失败
                                ↓
                    返回"系统繁忙，请稍后重试"
                                ↓
                    运维恢复Redis
                                ↓
                    重新库存预热

【场景3：MySQL乐观锁冲突】
                                ↓
                    UPDATE影响行数=0
                                ↓
                    重新查询version
                                ↓
                    再次UPDATE（最多重试3次）
                                ↓
                    3次还失败 → 进入死信队列
```

---

## 核心技术点总结

```
═══════════════════════════════════════════════════════════════════
                        核心技术点
═══════════════════════════════════════════════════════════════════

1. Redis Lua脚本：原子操作，防超卖
2. RocketMQ削峰填谷：10万QPS → 1000QPS
3. MySQL乐观锁：version字段，防并发
4. 防重复秒杀：Redis防线 + MySQL唯一索引
5. 异步解耦：用户等15ms，订单异步创建
6. 延迟消息：30分钟自动取消未支付订单
7. 重试机制：消费失败自动重试16次
8. 死信队列：重试失败人工处理
```

---

## 完整流程总结

| 阶段 | 名称 | 耗时 | 用户感知 | 核心技术 |
|------|------|------|----------|----------|
| 阶段一 | 库存预热 | 100ms | 无 | MySQL → Redis |
| 阶段二 | 用户秒杀 | 15ms | 有 | Redis Lua + RocketMQ |
| 阶段三 | 订单创建 | 200ms | 无 | RocketMQ + MySQL乐观锁 |
| 阶段四 | 数据验证 | 10ms | 无 | Redis = MySQL |
| 阶段五 | 支付流程 | 2000ms | 有 | 微信支付/支付宝 |
| 阶段六 | 超时取消 | 30分钟 | 无 | RocketMQ延迟消息 |
| 阶段七 | 异常处理 | 不定 | 无 | 重试+死信队列 |

---

## 时间线

```
T0：库存预热（MySQL → Redis）
    ↓
T1：用户秒杀（15ms）
    ├─ Redis扣库存
    ├─ 发送RocketMQ消息
    └─ 返回"秒杀成功"
    ↓
T2（2秒后）：订单创建（200ms）
    ├─ Consumer消费消息
    ├─ 扣减MySQL库存
    ├─ 创建订单
    └─ 记录日志
    ↓
T3（5分钟后）：用户支付（2000ms）
    ├─ 调用支付接口
    └─ 更新订单状态
    ↓
T4（30分钟后）：超时取消检查
    ├─ 查询订单状态
    ├─ 如果未支付 → 取消订单
    └─ 如果已支付 → 不处理
```

---

## 数据流转

```
第1步：MySQL（stock=10000）
    ↓ 预热
第2步：Redis（seckill:stock:1 = 10000）
    ↓ 秒杀
第3步：Redis（seckill:stock:1 = 9999）
    ↓ 发送MQ
第4步：RocketMQ（消息队列）
    ↓ 推送消息
第5步：MySQL（stock=9999, version=1）
    ↓ 创建订单
第6步：MySQL（tb_seckill_order插入1条）
    ↓ 记录日志
第7步：MySQL（tb_stock_log插入1条）
    ↓ 记录用户
第8步：MySQL（tb_user_seckill插入1条）
    ↓ 验证
第9步：Redis = MySQL（数据一致）
```

---

## 防超卖和防重复机制

### 防超卖的3道防线

```
第1道防线：Redis Lua脚本
    ├─ 原子操作：读、判断、扣减一次完成
    └─ 绝对不超卖

第2道防线：MySQL乐观锁
    ├─ WHERE version=0
    └─ 只有一个线程能更新成功

第3道防线：库存日志
    ├─ 记录每次扣减
    └─ 方便排查问题
```

### 防重复秒杀的2道防线

```
第1道防线：Redis防线
    ├─ EXISTS seckill:user:1002:1
    └─ 秒杀前检查

第2道防线：MySQL防线
    ├─ tb_user_seckill表
    └─ 唯一索引uk_user_product(user_id, product_id)
```

---

## RocketMQ在秒杀中的3大作用

### 作用1：削峰填谷
```
10万并发请求
    ↓ Redis快速扣库存（15ms）
RocketMQ消息队列
    ↓ 控制消费速度（1000个/秒）
MySQL压力小（1000QPS）
```

### 作用2：异步解耦
```
用户等待时间：15ms（只等Redis+发MQ）
订单创建时间：200ms（异步处理，用户无感知）
```

### 作用3：保证消息不丢失
```
持久化：消息写入磁盘
重试机制：失败自动重试16次
死信队列：重试失败人工处理
```

---

**文档版本：** v1.0  
**最后更新：** 2026-02-09  
**作者：** Kiro AI
