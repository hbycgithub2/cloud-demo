# Gateway 请求限流 - 超简单版

## 一、人话版（一句话）

**限流就像景区限流：**
- 景区每小时只能进 1000 人（限流规则）
- 第 1001 个人来了，不让进（拒绝请求）
- 等下一个小时再来（稍后重试）
- 防止人太多，景区崩溃（防止服务器崩溃）

---

## 二、为什么需要限流？

### 场景：没有限流（服务器崩溃）

```
正常情况：
  每秒 100 个请求 → 服务器处理 ✅

突然流量暴增：
  每秒 10000 个请求 → 服务器处理不过来 ❌
  
结果：
  - 服务器 CPU 100%
  - 内存耗尽
  - 数据库连接池满了
  - 服务器崩溃
  - 所有用户都无法访问
```

**人话：**
- 就像餐厅只有 10 张桌子
- 突然来了 100 个客人
- 餐厅挤爆了，谁都吃不了饭
- 餐厅崩溃

---

### 场景：有限流（保护服务器）

```
正常情况：
  每秒 100 个请求 → 服务器处理 ✅

突然流量暴增：
  每秒 10000 个请求
  → 限流：只允许 1000 个请求通过
  → 其他 9000 个请求被拒绝
  
结果：
  - 服务器处理 1000 个请求 ✅
  - 9000 个请求被拒绝（返回 429 错误）
  - 服务器不会崩溃
  - 至少 1000 个用户可以正常访问
```

**人话：**
- 就像餐厅只有 10 张桌子
- 突然来了 100 个客人
- 餐厅说：只能进 10 个，其他人排队
- 至少 10 个客人可以吃饭
- 餐厅不会崩溃

---

## 三、限流算法

### 算法 1：计数器（最简单）

```
规则：每秒最多 100 个请求

实现：
  1. 记录当前秒的请求数
  2. 每来一个请求，计数器 +1
  3. 如果计数器 > 100，拒绝请求
  4. 下一秒，计数器清零

示例：
  第 1 秒：
    请求 1 → 计数器 = 1 → 通过 ✅
    请求 2 → 计数器 = 2 → 通过 ✅
    ...
    请求 100 → 计数器 = 100 → 通过 ✅
    请求 101 → 计数器 = 101 → 拒绝 ❌
  
  第 2 秒：
    计数器清零 = 0
    请求 1 → 计数器 = 1 → 通过 ✅
    ...
```

**优点：**
- ✅ 简单易懂
- ✅ 实现简单

**缺点：**
- ❌ 有临界问题（下面解释）

---

### 算法 2：滑动窗口（推荐）✅

```
规则：每秒最多 100 个请求

实现：
  1. 记录最近 1 秒内的请求时间
  2. 每来一个请求，检查最近 1 秒内有多少个请求
  3. 如果 < 100，通过；如果 >= 100，拒绝

示例：
  当前时间：10:00:00.500
  
  检查最近 1 秒（10:00:00.500 - 1秒 = 09:59:59.500）：
    09:59:59.600 → 请求 1
    09:59:59.700 → 请求 2
    ...
    10:00:00.400 → 请求 99
    
  总共 99 个请求 < 100 → 通过 ✅
  
  下一个请求：
    10:00:00.600 → 请求 100
    
  检查最近 1 秒（10:00:00.600 - 1秒 = 09:59:59.600）：
    09:59:59.600 → 请求 1（刚好 1 秒前，还算）
    09:59:59.700 → 请求 2
    ...
    10:00:00.600 → 请求 100
    
  总共 100 个请求 = 100 → 通过 ✅
  
  下一个请求：
    10:00:00.700 → 请求 101
    
  检查最近 1 秒（10:00:00.700 - 1秒 = 09:59:59.700）：
    09:59:59.700 → 请求 2（请求 1 已经超过 1 秒了，不算）
    09:59:59.800 → 请求 3
    ...
    10:00:00.700 → 请求 101
    
  总共 100 个请求 = 100 → 拒绝 ❌
```

**优点：**
- ✅ 没有临界问题
- ✅ 更精确

**缺点：**
- ⚠️ 实现稍微复杂

---

### 算法 3：令牌桶（最常用）✅

```
规则：每秒最多 100 个请求

实现：
  1. 有一个桶，桶里有令牌
  2. 每秒往桶里放 100 个令牌
  3. 每来一个请求，从桶里拿 1 个令牌
  4. 如果桶里有令牌，通过；如果没有令牌，拒绝

示例：
  初始状态：
    桶里有 100 个令牌
  
  请求 1 来了：
    从桶里拿 1 个令牌 → 桶里还有 99 个 → 通过 ✅
  
  请求 2 来了：
    从桶里拿 1 个令牌 → 桶里还有 98 个 → 通过 ✅
  
  ...
  
  请求 100 来了：
    从桶里拿 1 个令牌 → 桶里还有 0 个 → 通过 ✅
  
  请求 101 来了：
    从桶里拿 1 个令牌 → 桶里没有令牌了 → 拒绝 ❌
  
  1 秒后：
    往桶里放 100 个令牌 → 桶里有 100 个令牌
    
  请求 102 来了：
    从桶里拿 1 个令牌 → 桶里还有 99 个 → 通过 ✅
```

**优点：**
- ✅ 可以应对突发流量
- ✅ 最常用

**缺点：**
- ⚠️ 实现稍微复杂

---

## 四、完整流程图（以 UserService 为例）

### 场景：限流规则（每秒最多 10 个请求）

```
┌─────────────────────────────────────────────────────────────────┐
│  第 1 步：客户端发送请求                                         │
│                                                                 │
│  客户端 1：GET /user/1                                           │
│  客户端 2：GET /user/2                                           │
│  客户端 3：GET /user/3                                           │
│  ...                                                            │
│  客户端 11：GET /user/11                                         │
│                                                                 │
│  11 个请求同时到达 Gateway                                       │
└─────────────────────────────────────────────────────────────────┘
                            │
                            │ 11 个请求
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  第 2 步：Gateway 收到请求                                       │
│                                                                 │
│  Gateway 收到 11 个请求：                                        │
│    请求 1：GET /user/1                                           │
│    请求 2：GET /user/2                                           │
│    ...                                                          │
│    请求 11：GET /user/11                                         │
│                                                                 │
│  Gateway 想：这么多请求，我得限流！                              │
└─────────────────────────────────────────────────────────────────┘
                            │
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  第 3 步：限流过滤器（RateLimitFilter）                          │
│                                                                 │
│  限流规则：                                                      │
│    路径：/user/**                                                │
│    限制：每秒最多 10 个请求                                      │
│                                                                 │
│  检查当前秒的请求数：                                            │
│    当前时间：10:00:00                                            │
│    当前秒已有请求数：0                                           │
│                                                                 │
│  处理请求 1：                                                    │
│    请求数 = 0 + 1 = 1                                            │
│    1 <= 10？✅ 是的，通过                                        │
│                                                                 │
│  处理请求 2：                                                    │
│    请求数 = 1 + 1 = 2                                            │
│    2 <= 10？✅ 是的，通过                                        │
│                                                                 │
│  ...                                                            │
│                                                                 │
│  处理请求 10：                                                   │
│    请求数 = 9 + 1 = 10                                           │
│    10 <= 10？✅ 是的，通过                                       │
│                                                                 │
│  处理请求 11：                                                   │
│    请求数 = 10 + 1 = 11                                          │
│    11 <= 10？❌ 不是，拒绝！                                     │
│                                                                 │
│  结果：                                                          │
│    前 10 个请求 → 通过 ✅                                        │
│    第 11 个请求 → 拒绝 ❌                                        │
└─────────────────────────────────────────────────────────────────┘
                            │
                            ├─ 前 10 个请求（通过）
                            │
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  第 4 步：转发到 UserService（前 10 个请求）                     │
│                                                                 │
│  Gateway → UserService：                                         │
│    请求 1：GET http://localhost:8081/user/1                     │
│    请求 2：GET http://localhost:8081/user/2                     │
│    ...                                                          │
│    请求 10：GET http://localhost:8081/user/10                   │
└─────────────────────────────────────────────────────────────────┘
                            │
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  第 5 步：UserService 处理请求                                   │
│                                                                 │
│  UserService 收到 10 个请求：                                    │
│    查数据库，返回数据                                            │
│                                                                 │
│  UserService 想：                                                │
│    只有 10 个请求，我能处理 ✅                                   │
└─────────────────────────────────────────────────────────────────┘
                            │
                            │ 返回数据
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  第 6 步：Gateway 转发响应（前 10 个请求）                       │
│                                                                 │
│  Gateway → 客户端 1-10：                                         │
│    {"id":1,"username":"柳岩","address":"湖南"}                   │
│    {"id":2,"username":"张三","address":"北京"}                   │
│    ...                                                          │
└─────────────────────────────────────────────────────────────────┘
                            │
                            │ 第 11 个请求（被拒绝）
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  第 7 步：返回限流错误（第 11 个请求）                           │
│                                                                 │
│  Gateway → 客户端 11：                                           │
│    状态码：429 Too Many Requests                                │
│    消息：请求过多，请稍后重试                                    │
│                                                                 │
│  客户端 11 想：                                                  │
│    被限流了，等一会儿再试                                        │
└─────────────────────────────────────────────────────────────────┘
```

---

## 五、简化版流程图

```
客户端 1-11
  │
  │ ① 发送 11 个请求
  ↓
Gateway (10010)
  │
  │ ② 收到 11 个请求
  │ ③ 限流过滤器检查
  │    规则：每秒最多 10 个请求
  │    当前秒已有：0 个
  │    
  │    请求 1-10：0+10 = 10 <= 10 ✅ 通过
  │    请求 11：10+1 = 11 > 10 ❌ 拒绝
  │
  ├─ 请求 1-10（通过）
  │   │
  │   │ ④ 转发到 UserService
  │   ↓
  │  UserService (8081)
  │   │
  │   │ ⑤ 处理请求
  │   │ ⑥ 返回数据
  │   ↓
  │  Gateway
  │   │
  │   │ ⑦ 转发响应
  │   ↓
  │  客户端 1-10
  │   │
  │   │ ⑧ 收到数据 ✅
  │
  └─ 请求 11（拒绝）
      │
      │ ④ 返回 429 错误
      ↓
     客户端 11
      │
      │ ⑤ 收到错误：请求过多 ❌
```

---

## 六、核心代码

### 限流过滤器

```java
@Component
public class RateLimitFilter implements GlobalFilter, Ordered {
    
    // 限流规则：每秒最多 10 个请求
    private static final int MAX_REQUESTS_PER_SECOND = 10;
    
    // 记录当前秒的请求数
    private Map<String, AtomicInteger> requestCountMap = new ConcurrentHashMap<>();
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 1. 获取当前秒（精确到秒）
        String currentSecond = String.valueOf(System.currentTimeMillis() / 1000);
        
        // 2. 获取当前秒的请求数
        AtomicInteger count = requestCountMap.computeIfAbsent(
            currentSecond, 
            k -> new AtomicInteger(0)
        );
        
        // 3. 请求数 +1
        int currentCount = count.incrementAndGet();
        
        // 4. 检查是否超过限制
        if (currentCount > MAX_REQUESTS_PER_SECOND) {
            // 超过限制，拒绝请求
            exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
            return exchange.getResponse().setComplete();
        }
        
        // 5. 没有超过限制，放行
        return chain.filter(exchange);
    }
    
    @Override
    public int getOrder() {
        return -1;  // 优先级最高
    }
}
```

**人话翻译：**

```java
public Mono<Void> filter(...) {
    // 1. 获取当前是第几秒
    String currentSecond = 当前时间（精确到秒）;
    
    // 2. 获取这一秒已经有多少个请求了
    int count = 从 Map 里获取(currentSecond);
    
    // 3. 请求数 +1
    count = count + 1;
    
    // 4. 检查是否超过限制（10 个）
    if (count > 10) {
        // 超过了，拒绝
        return 返回 429 错误;
    }
    
    // 5. 没超过，放行
    return 继续往下走;
}
```

---

### 使用 Redis 实现限流（推荐）✅

```java
@Component
public class RedisRateLimitFilter implements GlobalFilter, Ordered {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    private static final int MAX_REQUESTS_PER_SECOND = 10;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 1. 获取当前秒
        String currentSecond = String.valueOf(System.currentTimeMillis() / 1000);
        
        // 2. Redis key
        String key = "rate_limit:" + currentSecond;
        
        // 3. 请求数 +1
        Long count = redisTemplate.opsForValue().increment(key);
        
        // 4. 设置过期时间（2 秒后自动删除）
        if (count == 1) {
            redisTemplate.expire(key, 2, TimeUnit.SECONDS);
        }
        
        // 5. 检查是否超过限制
        if (count > MAX_REQUESTS_PER_SECOND) {
            // 超过限制，拒绝请求
            exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
            return exchange.getResponse().setComplete();
        }
        
        // 6. 没有超过限制，放行
        return chain.filter(exchange);
    }
    
    @Override
    public int getOrder() {
        return -1;
    }
}
```

**优点：**
- ✅ 分布式限流（多个 Gateway 共享限流）
- ✅ 自动清理过期数据

---

## 七、限流策略

### 策略 1：全局限流

```
规则：所有请求，每秒最多 1000 个

适用场景：
  - 保护整个系统
  - 防止服务器崩溃
```

---

### 策略 2：接口限流

```
规则：
  - /user/** 每秒最多 100 个请求
  - /order/** 每秒最多 50 个请求
  - /product/** 每秒最多 200 个请求

适用场景：
  - 不同接口有不同的处理能力
  - 重要接口限制更严格
```

---

### 策略 3：用户限流

```
规则：每个用户每秒最多 10 个请求

适用场景：
  - 防止单个用户恶意刷接口
  - 防止爬虫
```

---

### 策略 4：IP 限流

```
规则：每个 IP 每秒最多 100 个请求

适用场景：
  - 防止 DDoS 攻击
  - 防止恶意请求
```

---

## 八、总结

### 为什么需要限流

```
没有限流：
  - 流量暴增 → 服务器崩溃 → 所有用户都无法访问

有限流：
  - 流量暴增 → 限流保护 → 部分用户可以访问
  - 至少保证系统不崩溃
```

### 限流算法

```
1. 计数器：最简单，有临界问题
2. 滑动窗口：更精确，实现稍复杂
3. 令牌桶：最常用，可以应对突发流量 ✅
```

### 限流策略

```
1. 全局限流：保护整个系统
2. 接口限流：不同接口不同限制
3. 用户限流：防止单个用户恶意刷接口
4. IP 限流：防止 DDoS 攻击
```

### 完整流程

```
1. 客户端发送请求
2. Gateway 收到请求
3. 限流过滤器检查
   - 请求数 <= 限制 → 通过 ✅
   - 请求数 > 限制 → 拒绝 ❌（返回 429）
4. 通过的请求转发到 UserService
5. UserService 处理请求
6. 返回数据
```

### 一句话总结

**限流就像景区限流：每小时只能进 1000 人，第 1001 个人不让进，防止人太多景区崩溃。Gateway 限流也是一样：每秒只允许一定数量的请求通过，超过的请求被拒绝（返回 429），保护服务器不崩溃！**
